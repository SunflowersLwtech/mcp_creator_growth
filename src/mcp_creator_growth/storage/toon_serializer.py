"""
TOON Serializer (Prototype)
===========================

Implements a basic Token-Oriented Object Notation (TOON) serializer.
TOON is designed to reduce token usage by using indentation and minimal punctuation.
"""

from typing import Any

class ToonSerializer:
    """
    A prototype serializer for TOON format.

    Format Rules (Simplified):
    - Indentation defines structure (2 spaces).
    - No braces or brackets.
    - Key-value: `key: value`
    - List item: `- value`
    """

    @staticmethod
    def dump(data: Any, indent_level: int = 0) -> str:
        """
        Serialize data to TOON string.
        """
        indent = "  " * indent_level
        output = []

        if isinstance(data, dict):
            for key, value in data.items():
                if isinstance(value, (dict, list)):
                    # Special case: empty structures
                    if not value:
                         output.append(f"{indent}{key}: {value}")
                         continue

                    output.append(f"{indent}{key}:")
                    output.append(ToonSerializer.dump(value, indent_level + 1))
                else:
                    output.append(f"{indent}{key}: {value}")

        elif isinstance(data, list):
            for item in data:
                if isinstance(item, dict):
                    # Compact list object representation
                    # - key: val
                    #   other: val
                    keys = list(item.keys())
                    if keys:
                        first_k = keys[0]
                        output.append(f"{indent}- {first_k}: {item[first_k]}")
                        # Rest of the dict
                        sub_dict = {k: item[k] for k in keys[1:]}
                        if sub_dict:
                            # We need to manually indent the rest of the dict to match the list item
                            sub_dump = ToonSerializer.dump(sub_dict, indent_level + 1)
                            output.append(sub_dump)
                    else:
                         output.append(f"{indent}- {{}}")
                elif isinstance(item, list):
                     output.append(f"{indent}-")
                     output.append(ToonSerializer.dump(item, indent_level + 1))
                else:
                    output.append(f"{indent}- {item}")

        else:
             return str(data)

        return "\n".join(output)

    @staticmethod
    def load(toon_str: str) -> Any:
        """
        Deserialize TOON string to data.

        Note: This is a simplified recursive parser.
        It assumes the input was generated by ToonSerializer or strictly follows the format.
        """
        lines = [line for line in toon_str.split("\n") if line.strip()]
        if not lines:
            return {}

        result, _ = ToonSerializer._parse_block(lines, 0)
        return result

    @staticmethod
    def _parse_block(lines: list[str], current_indent: int) -> tuple[Any, list[str]]:
        """
        Parses a block of lines at the same indentation level.
        Returns (parsed_object, remaining_lines)
        """
        if not lines:
            return {}, []

        first_line = lines[0]
        actual_indent = len(first_line) - len(first_line.lstrip())

        if actual_indent < current_indent:
            return None, lines

        is_list = first_line.strip().startswith("-")
        container: Any = [] if is_list else {}

        while lines:
            line = lines[0]
            indent = len(line) - len(line.lstrip())

            if indent < current_indent:
                break

            # Sub-block handling (should have been consumed, but safeguard)
            if indent > current_indent:
                 # This logic assumes the parent loop calls _parse_block for children
                 # If we see greater indent here, it means we are inside a value that spans lines
                 # but for this simple parser, we skip or it's an error in logic
                 pass

            stripped = line.strip()

            if is_list:
                if stripped.startswith("- "):
                    value_part = stripped[2:]

                    # Check for inline key-value (dict inside list)
                    if ": " in value_part:
                         k, v = value_part.split(": ", 1)
                         item = {k: v}

                         # Look ahead for more properties of this item
                         nested_lines = []
                         idx = 1
                         while idx < len(lines):
                             next_indent = len(lines[idx]) - len(lines[idx].lstrip())
                             if next_indent > indent: # Stricter: must be indented relative to the list item start
                                 nested_lines.append(lines[idx])
                                 idx += 1
                             else:
                                 break

                         if nested_lines:
                             parsed_sub, _ = ToonSerializer._parse_block(nested_lines, indent + 2)
                             if isinstance(parsed_sub, dict):
                                 item.update(parsed_sub)

                         container.append(item)
                         lines = lines[idx:]
                         continue

                    else:
                        container.append(value_part)
                        lines = lines[1:]
                elif stripped == "-":
                     # Nested list start
                     nested_lines = []
                     idx = 1
                     while idx < len(lines):
                         next_indent = len(lines[idx]) - len(lines[idx].lstrip())
                         if next_indent > indent:
                             nested_lines.append(lines[idx])
                             idx += 1
                         else:
                             break

                     if nested_lines:
                         parsed_sub, _ = ToonSerializer._parse_block(nested_lines, indent + 2)
                         container.append(parsed_sub)
                     else:
                         container.append([])
                     lines = lines[idx:]
                else:
                    lines = lines[1:]

            else:
                # Dict
                if ": " in stripped:
                    key, value = stripped.split(": ", 1)
                    # Check for nested block
                    nested_lines = []
                    idx = 1
                    while idx < len(lines):
                        next_indent = len(lines[idx]) - len(lines[idx].lstrip())
                        if next_indent > indent:
                            nested_lines.append(lines[idx])
                            idx += 1
                        else:
                            break

                    if nested_lines:
                        # If we have children, they are the value (or merge into it)
                        parsed_sub, _ = ToonSerializer._parse_block(nested_lines, indent + 2)
                        container[key] = parsed_sub
                    else:
                        container[key] = value

                    lines = lines[idx:]

                elif stripped.endswith(":"):
                     key = stripped[:-1]
                     nested_lines = []
                     idx = 1
                     while idx < len(lines):
                        next_indent = len(lines[idx]) - len(lines[idx].lstrip())
                        if next_indent > indent:
                            nested_lines.append(lines[idx])
                            idx += 1
                        else:
                            break
                     if nested_lines:
                        parsed_sub, _ = ToonSerializer._parse_block(nested_lines, indent + 2)
                        container[key] = parsed_sub
                     else:
                        container[key] = {} # Empty dict
                     lines = lines[idx:]

                else:
                    # Unknown line format
                    lines = lines[1:]

        return container, lines
